import os
from dotenv import load_dotenv
load_dotenv()
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from datetime import datetime, timezone, timezone
import time
import json
from pathlib import Path
import ccxt
from nova.engine import bandit
from nova.strategies import (
    ema_cross, rsi_reversion, breakout, macd,
    bb_breakout, meanrev_z, vwap_pullback,
    keltner_breakout, adx_filter
)
LOGF = Path("logs/engine.log")
def LOG_write(msg):
    ts = datetime.now(timezone.utc).isoformat(timespec='seconds')
    ex = os.getenv('EXCHANGE')
    mode = os.getenv('MODE')
    line = f"{ts} {msg}"
    print(line, flush=True)
    with LOGF.open("a") as f:
        f.write(f"{ts} {msg}\n")

class Engine:

    def _vote(self, symbol, t, ohlc):
        """Samler stemmer fra strategier, vekter med bandit + basevekt, lagrer til data/strat_votes.json."""
        import json
        from pathlib import Path
        from datetime import datetime, timezone, timezone
        try:
            arms = [name for (name, *_rest) in self.strats]
        except Exception:
            arms = []
        try:
            from nova.engine import bandit
            bw = bandit.get_weights(arms) if arms else {}
        except Exception:
            bw = {}
        votes = {}
        for (name, state, fn, basew) in getattr(self, "strats", []):
            raw = 0.0
            try:
                sig, _meta = fn(t, ohlc, state)
                raw = 1.0 if sig == 'buy' else (-1.0 if sig == 'sell' else 0.0)
            except Exception as e:
                raw = 0.0
            votes[name] = raw * float(basew) * float(bw.get(name, 1.0))
        total = sum(votes.values()) if votes else 0.0
        # persist for exporter
        Path('data').mkdir(exist_ok=True)
        snap = {"ts": datetime.now(timezone.utc).isoformat(timespec="seconds")+"Z",
                "symbol": symbol, "votes": votes, "total": total}
        try:
            Path('data/strat_votes.json').write_text(json.dumps(snap, indent=2))
        except Exception:
            pass
        if total > 0.8:   decision = 'buy'
        elif total < -0.8: decision = 'sell'
        else:              decision = 'hold'
        return decision, {"votes": votes, "total": total}
    def _write_metrics(self, tf, syms, ohlc_map, last_px):
    import os
    base_ccy = os.getenv('BASE_CCY','USDT')
    cash = float(getattr(self, 'cash', float(os.getenv('START_CASH','10000'))))
    trades = int(getattr(self, 'trades', 0))
    realized = float(getattr(self, 'realized', 0.0))
    positions = getattr(self, 'positions', {}) or {}

    unreal = 0.0
    for sym, pos in positions.items():
        qty = float(pos.get('qty', 0.0) or 0.0)
        avg = float(pos.get('avg', 0.0) or 0.0)
        px  = last_px.get(sym)
        if qty and px is not None:
            unreal += (px - avg) * qty

    equity = cash + unreal

    out = []
    out += ["# HELP novax_up Always 1 if exporter alive",
            "# TYPE novax_up gauge",
            "novax_up 1"]
    out += ["# HELP novax_equity Paper equity in base ccy",
            "# TYPE novax_equity gauge",
            f'novax_equity{{ccy="{base_ccy}"}} {equity}']
    out += ["# HELP novax_cash Free cash",
            "# TYPE novax_cash gauge",
            f'novax_cash{{ccy="{base_ccy}"}} {cash}']
    out += ["# HELP novax_trades_total Total trades",
            "# TYPE novax_trades_total counter",
            f'novax_trades_total {trades}']
    out += ["# HELP novax_pnl_realized Realized PnL",
            "# TYPE novax_pnl_realized counter",
            f'novax_pnl_realized {realized}']
    out += ["# HELP novax_pnl_unrealized Unrealized PnL",
            "# TYPE novax_pnl_unrealized gauge",
            f'novax_pnl_unrealized {unreal}']

    for sym, pos in positions.items():
        out.append(f'novax_position_qty{{symbol="{sym}"}} {float(pos.get("qty",0.0) or 0.0)}')
        px = last_px.get(sym)
        if px is not None:
            out.append(f'novax_last_price{{symbol="{sym}"}} {px}')

    from pathlib import Path as _P
    _P("runtime").mkdir(exist_ok=True)
    _P("runtime/metrics.prom").write_text("\\n".join(out) + "\\n", encoding="utf-8")

def main():
    LOG_write('engine boot: ' + str(os.getenv('EXCHANGE')) + ' / ' + str(os.getenv('MODE')))
    eng = Engine(cfg=os.environ.copy())
    # initial metrics on boot
    try:
        eng._write_metrics(os.getenv('TIMEFRAME','1h'), [], {}, {})
    except Exception:
        pass
    # fallback: symbols/timeframe fra ENV eller defaults
    syms_env = os.getenv('SYMBOLS','BTC/USDT,ETH/USDT').split(',')
    eng.universe = [x.strip() for x in syms_env if x.strip()]
    if not hasattr(eng, 'params') or eng.params is None:
        eng.params = {}
    eng.params.setdefault('timeframe', os.getenv('TIMEFRAME','1h'))
    backoff = 1.0
    while True:
        try:
            eng.loop()
            backoff = 1.0
        except Exception as e:
            LOG_write(f'engine loop error: {e}')
            backoff = min(backoff*2, 30.0)
        time.sleep(backoff)
    eng=Engine(cfg)
    LOG_write("engine boot: %s / %s"%(cfg.get("EXCHANGE"),cfg.get("MODE")))
    eng.loop()

if __name__=="__main__":
    main()


def _write_metrics(self, ohlc_map):
    import os
    from pathlib import Path as _P
    base_ccy = os.getenv('BASE_CCY','USDT')
    equity   = float(getattr(self, 'equity', 10000.0))
    cash     = float(getattr(self, 'cash',   10000.0))
    trades   = int(getattr(self, 'trades',  0))
    pnl_r    = float(getattr(self, 'pnl_realized',   0.0))
    pnl_u    = float(getattr(self, 'pnl_unrealized', 0.0))

    out = [
        "# HELP novax_up Always 1 if exporter alive",
        "# TYPE novax_up gauge",
        "novax_up 1",
        "# HELP novax_equity Paper equity in base ccy",
        "# TYPE novax_equity gauge",
        f'novax_equity{{ccy="{base_ccy}"}} {equity}',
        "# HELP novax_cash Free cash",
        "# TYPE novax_cash gauge",
        f'novax_cash{{ccy="{base_ccy}"}} {cash}',
        "# HELP novax_trades_total Total trades",
        "# TYPE novax_trades_total counter",
        f'novax_trades_total {trades}',
        "# HELP novax_pnl_realized Realized PnL",
        "# TYPE novax_pnl_realized counter",
        f'novax_pnl_realized {pnl_r}',
        "# HELP novax_pnl_unrealized Unrealized PnL",
        "# TYPE novax_pnl_unrealized gauge",
        f'novax_pnl_unrealized {pnl_u}',
    ]

    positions = getattr(self, 'positions', {}) or {}
    for sym, pos in positions.items():
        qty = float(pos.get('qty', 0.0))
        out.append(f'novax_position_qty{{symbol="{sym}"}} {qty}')

    _P("runtime").mkdir(exist_ok=True)
    _P("runtime/metrics.prom").write_text("\n".join(out) + "\n", encoding="utf-8")


def loop(self):
    import os, time
    tf = os.getenv('TIMEFRAME', self.params.get('timeframe','1h'))
    syms = self.universe[: min(50, len(self.universe))]
    if not syms:
        syms = [x.strip() for x in os.getenv('SYMBOLS','BTC/USDT,ETH/USDT,SOL/USDT').split(',') if x.strip()]

    ohlc_map = {}
    for s_ in syms:
        for _try in range(3):
            try:
                ohlc_map[s_] = self.ex.fetch_ohlcv(s_, timeframe=tf, limit=200)
                break
            except Exception as e:
                LOG_write(f'fetch_ohlcv fail {s_}/{tf}: {e}')
                if _try == 2:
                    pass
                time.sleep(1.0)

    LOG_write(f'loop ok syms={len(syms)} tf={tf} ohlc_keys={len(ohlc_map)}')
    self._write_metrics(ohlc_map)
    return
